#include<iostream>
#include<string>
using namespace std;
// 책 페이지
// 각 자리수가 일정한 규칙에 따라
// 반복적으로 등장한다는 규칙을 사용

// ex. 145 인 경우,
// 1의 자리의 수들은 앞의 자리인 '14' 만큼은 1회 반복적으로 모두 등장
// +) 1,2,3,4,5 는 추가로 1회 등장
// 10의 자리는 '1' 만큼은 10회 씩 반복적으로 모두 등장
// +) 1,2,3 은 10회, 4 는 6회 추가로 등장 (140, 141, 142, 143, 144, 145)

// 자릿수가 늘어날수록, 사이클 한 번에 등장하는 수는 10배 증가하며
// 사이클에 묶이지 못한 값은 자신의 하위 자릿수의 영향을 받음

// 1 부터 증가하며, 이후 0 이 등장하는 형식으로
// 0 에 대한 예외처리가 상당히 까다로웠음

int cnt[10];
string str;

int main() {
	cin >> str; // 입력 숫자 (문자열)

	int idx = str.length() - 1; // 1의 자리 (가장 끝 글자)
	int repeat = 1; // 한 차례 반복마다 등장할 수의 갯수 
	while (idx >= 0) { // 가장 큰 자릿수까지 모두 살펴봄
		int head = str[idx] - '0'; // 현재 자릿수 값
		int front = atoi(str.substr(0, idx).c_str()); // 그보다 큰 자릿수 값
		int back = atoi(str.substr(idx + 1, str.length()).c_str()); // 작은 자릿수 값

		for (int k = 0; k < 10; k++) { // 0부터 모든 수는 큰 자릿수만큼 규칙적으로 반복됨
			cnt[k] += front * repeat; // so, 앞 자리 수 * 사이클 별 등장 횟수
		}
		cnt[0] -= repeat; // 다만 0의 경우, 가장 처음에 등장하는 케이스는 한번 빼야 함 (예외처리)

		// 이후 남은 자투리에 대한 처리
		for (int k = 0; k < head; k++) { // 이전 값까진 해당 규칙을 유지
			cnt[k] += repeat;
		}
		cnt[head] += back + 1; // 마지막 등장 값은 사이클이 아닌 뒤에 등장하는 수의 크기만큼 등장

		idx -= 1; // 다음 자릿수로 넘어감
		repeat *= 10; // 사이클 당 등장 횟수 10회 증가
	}

	for (int k = 0; k < 10; k++) { // 출력
		cout << cnt[k] << " ";
	}
}