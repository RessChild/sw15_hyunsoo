#include<iostream>
using namespace std;
// 산책
// N 이라는 반복 횟수를 줄이기 위해서 진행방향을 규칙에 따라 한번에 판단할 생각
// 어떤 교차로에 진입 했을때, 해당 교차로 진입 횟수가 홀수번 = 그대로, 짝수번 = 변경
// 즉 (이전 교차로 진입값 + 1) / 2 라는 규칙이 성립
// 1~2 번 : 다음교차로 1회 진입 / 3~4번 : 2번 진입 / 5~6 번 : 3회 진입 / ...

// 다만, 선택된 경로만 방향성에 영향을 준다고 생각했음
// 실제로는 모든 경로가 진행되면서 다음 경로에 영향을 주므로,
// 경로를 버리지말고 모두 누적시켜야 함

#define MAX 1002 // 맵 크기는 최대 1000 + 예외처리용 2

int sum[MAX][MAX], map[MAX][MAX];

int main() {
	int H, W, N;
	cin >> H >> W >> N; // 세로, 가로, 산책 횟수
	for (int k = 1; k <= H; k++)
		for (int m = 1; m <= W; m++)
			cin >> map[k][m]; // 초기 이정표 형태

	int x = 1, y = 1; // 초기 시작 위치 고정
	sum[1][1] = N; // 시작점은 총 N 번 진입함

	for (int k = 1; k <= H; k++) { 
		for (int m = 1; m <= W; m++) { 
			sum[k][m + 1] += sum[k][m] / 2 + (sum[k][m] % 2) * ("01"[map[k][m]] - '0'); // 가로 방향 전파
			sum[k + 1][m] += sum[k][m] / 2 + (sum[k][m] % 2) * ("10"[map[k][m]] - '0'); // 세로 방향 전파
		}
	} // 진행 방향은 항상 왼쪽, 아래로 이동하므로, 단순 반복문으로 충분

	while (x <= W && y <= H) { // 이후 각 위치의 진입 횟수를 기반으로 실제 N 번째 산책을 진행
		if (sum[y][x] % 2) { // 해당 위치에 짝수번 진입
			int s_x = x, s_y = y;
			x += "01"[map[s_y][s_x]] - '0';
			y += "10"[map[s_y][s_x]] - '0'; // 기존 값에서 방향을 틀어야 함
		}
		else { // 홀수번 진입
			int s_x = x, s_y = y;
			x += "10"[map[s_y][s_x]] - '0';
			y += "01"[map[s_y][s_x]] - '0'; // 기존 값 그대로 진행
		}
	}
	cout << y << " " << x << endl; // 도착 장소 출력
}